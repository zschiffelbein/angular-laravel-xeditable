/**
 * editablePromiseCollection
 *
 * Collect results of function calls. Shows waiting if there are promises.
 * Finally, applies callbacks if:
 * - onTrue(): all results are true and all promises resolved to true
 * - onFalse(): at least one result is false or promise resolved to false
 * - onString(): at least one result is string or promise rejected or promise resolved to string
 * - onObject(): at least one result is an object or promis rejected
 */
angular.module('xeditable').factory('editablePromiseCollection', ['$q', function ($q) {

    function promiseCollection() {
        return {
            promises: [],
            hasFalse: false,
            hasString: false,
            hasObject: false,
            when: function (result, noPromise) {
                if (result === false) {
                    this.hasFalse = true;
                } else if (!noPromise && angular.isObject(result)) {
                    this.promises.push($q.when(result));
                } else if (angular.isObject(result)) {
                    this.hasObject = true;
                } else if (angular.isString(result)) {
                    this.hasString = true;
                } else { //result === true || result === undefined || result === null
                    return;
                }
            },
            //callbacks: onTrue, onFalse, onString
            then: function (callbacks) {
                callbacks = callbacks || {};
                var onTrue = callbacks.onTrue || angular.noop;
                var onFalse = callbacks.onFalse || angular.noop;
                var onString = callbacks.onString || angular.noop;
                var onObject = callbacks.onObject || angular.noop;
                var onWait = callbacks.onWait || angular.noop;

                var self = this;

                if (this.promises.length) {
                    onWait(true);
                    $q.all(this.promises).then(
                        //all resolved
                        function (results) {
                            onWait(false);
                            // Do not process response. Always assume true
                            applyCallback();
                        },
                        //some rejected
                        function (error) {
                            onWait(false);
                            self.when(error, true);
                            applyCallback(error);
                        }
                    );
                } else {
                    applyCallback();
                }

                function applyCallback(response) {
                    if (!self.hasString && !self.hasFalse && !self.hasObject) {
                        onTrue();
                    } else if (!self.hasString && self.hasFalse) {
                        onFalse();
                    } else if (self.hasObject) {
                        onObject(response);
                    } else {
                        onString(response);
                    }
                }

            }
        };
    }

    return promiseCollection;

}]);

/**
 * editableUtils
 */
angular.module('xeditable').factory('editableUtils', [function () {
    return {
        indexOf: function (array, obj) {
            if (array.indexOf) return array.indexOf(obj);

            for (var i = 0; i < array.length; i++) {
                if (obj === array[i]) return i;
            }
            return -1;
        },

        arrayRemove: function (array, value) {
            var index = this.indexOf(array, value);
            if (index >= 0) {
                array.splice(index, 1);
            }
            return value;
        },

        // copy from https://github.com/angular/angular.js/blob/master/src/Angular.js
        camelToDash: function (str) {
            var SNAKE_CASE_REGEXP = /[A-Z]/g;
            return str.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                return (pos ? '-' : '') + letter.toLowerCase();
            });
        },

        dashToCamel: function (str) {
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var MOZ_HACK_REGEXP = /^moz([A-Z])/;
            return str.
                replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
                    return offset ? letter.toUpperCase() : letter;
                }).
                replace(MOZ_HACK_REGEXP, 'Moz$1');
        }
    };
}]);

/**
 * editableNgOptionsParser
 *
 * see: https://github.com/angular/angular.js/blob/master/src/ng/directive/select.js#L131
 */
angular.module('xeditable').factory('editableNgOptionsParser', [
    function () {
        //0000111110000000000022220000000000000000000000333300000000000000444444444444444000000000555555555555555000000066666666666666600000000000000007777000000000000000000088888
        var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/;

        function parser(optionsExp) {
            var match;

            if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                throw 'ng-options parse error';
            }

            var
                displayFn = match[2] || match[1],
                valueName = match[4] || match[6],
                keyName = match[5],
                groupByFn = match[3] || '',
                valueFn = match[2] ? match[1] : valueName,
                valuesFn = match[7],
                track = match[8],
                trackFn = track ? match[8] : null;

            var ngRepeat;
            if (keyName === undefined) { // array
                ngRepeat = valueName + ' in ' + valuesFn;
                if (track !== undefined) {
                    ngRepeat += ' track by ' + trackFn;
                }
            } else { // object
                ngRepeat = '(' + keyName + ', ' + valueName + ') in ' + valuesFn;
            }

            // group not supported yet
            return {
                ngRepeat: ngRepeat,
                locals: {
                    valueName: valueName,
                    keyName: keyName,
                    valueFn: valueFn,
                    displayFn: displayFn
                }
            };
        }

        return parser;
    }]);
